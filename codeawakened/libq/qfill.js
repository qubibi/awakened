class qfill{static biasedRandom(){return Math.random()<.5?Math.pow(Math.random(),3):1-Math.pow(Math.random(),3)}static drawfillv2(t,e,r="#ffffff",n=1,a=0,o=0,l=[0,1],s=0,x=1){const d=e.length;if(d<2)return;t.stroke(r),t.strokeWeight(n),t.noFill();const i=(a%d+d)%d;t.beginShape(LINES);const y=Math.floor(d/2);for(let r=0;r<y;r++)if(Math.random()<x){const n=(d-1-r+i)%d,a=e[(r+i)%d],x=e[n];let y=qb.lerp(a,x,l[0]+qb.rndm(0,s),!1),f=qb.lerp(a,x,l[1]-qb.rndm(0,s),!1);y.x+=qb.rndm(-o,o),y.y+=qb.rndm(-o,o),f.x+=qb.rndm(-o,o),f.y+=qb.rndm(-o,o),t.vertex(y.x,y.y),t.vertex(f.x,f.y)}t.endShape()}static drawfill(t,e,r,n=0,a=0,o=0,l="#ffffff",s=1,x=0,d=0,i=0){t.stroke(l),t.strokeWeight(s),t.noFill();const y=1-o;for(let o=0;o<e.length;o++)if(Math.random()<y){const l=e[o],s=r[o],y=1-n,f=(1-y)*this.biasedRandom(),h=f+y,c={x:t.lerp(l.x,s.x,f)+qb.rndm(-a,a),y:t.lerp(l.y,s.y,f)+qb.rndm(-a,a)},m={x:t.lerp(l.x,s.x,h)+qb.rndm(-a,a),y:t.lerp(l.y,s.y,h)+qb.rndm(-a,a)};if(Math.random()<x){const e=.5*(c.x+m.x),r=.5*(c.y+m.y),n=m.x-c.x,a=m.y-c.y,o=Math.hypot(n,a),l=1/o,s=-a*l,x=n*l,y=o*(d+qb.rndm(-i,i)),f={x:e+s*y,y:r+x*y};t.beginShape();const h=7;for(let e=0;e<=h;e++){const r=e/h,n=1-r,a=r*r,o=n*n*c.x+2*n*r*f.x+a*m.x,l=n*n*c.y+2*n*r*f.y+a*m.y;t.vertex(o,l)}t.endShape()}else t.beginShape(),t.vertex(c.x,c.y),t.vertex(m.x,m.y),t.endShape()}}static quadraticPoint(t,e,r,n){let a=1-n,o=n*n,l=a*a*t.x+2*a*n*e.x+o*r.x,s=a*a*t.y+2*a*n*e.y+o*r.y;return createVector(l,s)}static shiftArray(t,e){const r=t.length;return e=(e%r+r)%r,t.slice(-e).concat(t.slice(0,-e))}}