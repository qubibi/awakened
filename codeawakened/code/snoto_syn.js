class Ssyn{constructor(){this.isPlaying=!1,this.maxVolume=.9*otomag_mp3,this.currentVolume=0,this.targetVolume=.2,this.volumeLerpFactor=.1,this.volumeNoiseOffset=0,this.volumeNoiseIncrement=.01,this.volumeNoiseRange={min:.1,max:this.maxVolume},this.samples={},this.baseMidiNote=57,this.baseFrequency=440,this.currentPitch=this.baseMidiNote,this.synthPool=[],this.poolSize=8,this.currentSynthIndex=0,this.lastPlayTime=0,this.playIntervalParams={min:3e3,max:2e4,current:1e4},this.isAutoPlaying=!1,this.chordProgression=[[57,62],[57,61],[45],[57,68],[47,51],[56],[61,70],[45],[57,60,64,67]],this.currentChordIndex=0,this.scales={major:[0,2,4,5,7,9,11],minor:[0,2,3,5,7,8,10],pentatonic:[0,2,4,7,9],original:[0,2,4,5,7,9]},this.currentScale=this.scales.major,this.rootNote=9,this.noteRepeatDelay=400,this.noteRepeatVolumeDecay=.94,this.noteRepeatPitchPatterns={pattern1:[0,2,-24],pattern2:[2,0,5],pattern5:[0,0,-24,0,0,-24,-1],pattern6:[0,1,2,3,4,5,4,3,2,1],pattern7:[0,12]},this.currentPatternName="pattern1",this.noteRepeatPitchShifts=this.noteRepeatPitchPatterns[this.currentPatternName],this.initialNoteRepeatCount=3,this.isFirstPlay=!0,this.noteRepeatCounts=[1,2,3,4,1,2,3,4,,8,16,24],this.filterParams={frequency:{min:200,max:6e3,current:1e3,noiseMin:200,noiseMax:2e3},Q:{min:.1,max:15,current:15}},this.filterNoiseOffset=0,this.filterNoiseIncrement=.03,this.delayParams={time:{min:.4,max:2.2,current:.37},feedback:{min:0,max:.1,current:0},wet:{min:.2,max:1,current:.5}},this.masterGainParams={current:1,noiseMin:.3,noiseMax:2.8},this.masterGainNoiseOffset=0,this.masterGainNoiseIncrement=.03,this.noteStaggerValues=[3,5,7,9,10,11,12,30,150,200]}setup(){for(let t=0;t<this.poolSize;t++)this.synthPool.push({sound:mp3s.syn1,isPlaying:!1,startTime:0});this.delay={input:inAudioContext.createGain(),output:inAudioContext.createGain(),wetGain:inAudioContext.createGain(),dryGain:inAudioContext.createGain(),delayNode:inAudioContext.createDelay(3),lowpass:inAudioContext.createBiquadFilter()},this.delay.delayNode.delayTime.value=this.delayParams.time.current,this.delay.wetGain.gain.value=this.delayParams.wet.current,this.delay.dryGain.gain.value=1,this.delay.lowpass.type="lowpass",this.delay.lowpass.frequency.value=this.filterParams.frequency.current,this.delay.lowpass.Q.value=this.filterParams.Q.current,this.delay.feedbackGain=inAudioContext.createGain(),this.delay.feedbackGain.gain.value=this.delayParams.feedback.current,this.delay.input.connect(this.delay.dryGain),this.delay.input.connect(this.delay.delayNode),this.delay.delayNode.connect(this.delay.wetGain),this.delay.delayNode.connect(this.delay.feedbackGain),this.delay.feedbackGain.connect(this.delay.delayNode),this.delay.dryGain.connect(this.delay.lowpass),this.delay.wetGain.connect(this.delay.lowpass),this.delay.lowpass.connect(this.delay.output),this.masterGain=inAudioContext.createGain(),this.masterGain.gain.value=1,mp3s.syn1Gain.disconnect(),mp3s.syn1Gain.connect(this.delay.input),mp3s.music2Gain.disconnect(),mp3s.music2Gain.connect(this.delay.input),this.delay.output.disconnect(),this.delay.output.connect(this.masterGain),this.masterGain.connect(inAudioContext.destination)}f_ef(){ssnoto.is_hindodown?(this.playIntervalParams={min:5e4,max:7e4,current:35e3},this.noteRepeatDelay=random(800,2e3)):(this.playIntervalParams={min:12e3,max:25e3,current:1e4},this.noteRepeatDelay=400);const t=noise(this.volumeNoiseOffset);if(this.volumeNoiseOffset+=this.volumeNoiseIncrement,this.targetVolume=map(t,0,1,this.volumeNoiseRange.min,this.volumeNoiseRange.max),this.targetVolume=Math.min(this.targetVolume,this.maxVolume),this.currentVolume=lerp(this.currentVolume,this.targetVolume,this.volumeLerpFactor),mp3s.syn1Gain.amp(this.currentVolume),this.updateIntervalPlayback(),this.synthPool.forEach((t=>{t.isPlaying&&!t.sound.isPlaying()&&(t.isPlaying=!1)})),this.delay&&this.delay.lowpass){const t=noise(this.filterNoiseOffset);this.filterNoiseOffset+=this.filterNoiseIncrement;const e=map(t,0,1,this.filterParams.frequency.noiseMin,this.filterParams.frequency.noiseMax);this.delay.lowpass.frequency.setTargetAtTime(e,inAudioContext.currentTime,.1)}if(this.masterGain){const t=noise(this.masterGainNoiseOffset);this.masterGainNoiseOffset+=this.masterGainNoiseIncrement;const e=map(t,0,1,this.masterGainParams.noiseMin,this.masterGainParams.noiseMax);this.masterGain.gain.setTargetAtTime(e,inAudioContext.currentTime,.1)}}updateIntervalPlayback(){if(!this.isAutoPlaying)return;const t=millis();if(t-this.lastPlayTime>this.playIntervalParams.current){const e=Object.keys(this.noteRepeatPitchPatterns),a=e[Math.floor(Math.random()*e.length)];this.changeNoteRepeatPattern(a),this.isFirstPlay||(this.noteRepeatCount=this.noteRepeatCounts[Math.floor(Math.random()*this.noteRepeatCounts.length)]),this.delayParams.time.current=Math.random()*(this.delayParams.time.max-this.delayParams.time.min)+this.delayParams.time.min,this.delayParams.feedback.current=Math.random()*(this.delayParams.feedback.max-this.delayParams.feedback.min)+this.delayParams.feedback.min,this.delayParams.wet.current=Math.random()*(this.delayParams.wet.max-this.delayParams.wet.min)+this.delayParams.wet.min,this.delay.delayNode.delayTime.value=this.delayParams.time.current,this.delay.feedbackGain.gain.value=this.delayParams.feedback.current,this.delay.wetGain.gain.value=this.delayParams.wet.current,this.playIntervalParams.current=Math.random()*(this.playIntervalParams.max-this.playIntervalParams.min)+this.playIntervalParams.min,this.playSample("syn1",this.chordProgression[this.currentChordIndex]),this.currentChordIndex=(this.currentChordIndex+1)%this.chordProgression.length,this.lastPlayTime=t}}playSample(t,e){const a=Array.isArray(e)?e:[e];mp3s.syn1Pool&&(this.targetVolume=this.maxVolume,this.isFirstPlay&&(this.noteRepeatCount=this.initialNoteRepeatCount,console.log("First play note repeat count:",this.noteRepeatCount),this.isFirstPlay=!1),this.playNotesWithNoteRepeat(a))}playNotes(t,e){t.forEach(((t,a)=>{const i=this.noteStaggerValues[Math.floor(Math.random()*this.noteStaggerValues.length)];setTimeout((()=>{const a=this.snapToScale(t),i=this.midiNoteToRate(a),s=Math.random();let n;n=s<.33?mp3s.syn1Pool:s<.66?mp3s.syn2Pool:mp3s.syn3Pool;const r=n[this.currentSynthIndex];r.rate(i),r.setVolume(this.maxVolume*e),r.play(),this.currentSynthIndex=(this.currentSynthIndex+1)%mp3s.syn1Pool.length}),i*a)}))}playNotesWithNoteRepeat(t){this.playNotes(t,1);for(let e=1;e<this.noteRepeatCount;e++)setTimeout((()=>{const a=Math.pow(this.noteRepeatVolumeDecay,e),i=this.noteRepeatPitchShifts[(e-1)%this.noteRepeatPitchShifts.length],s=t.map((t=>{let e=t+i;if(Math.random()<this.randomPitchChance){e+=Math.floor(Math.random()*(this.randomPitchRange[1]-this.randomPitchRange[0]+1))+this.randomPitchRange[0]}return e}));this.playNotes(s,a)}),this.noteRepeatDelay*e)}stopSample(t){mp3s.syn1&&mp3s.syn1.stop()}startAutoPlay(){this.isAutoPlaying=!0,this.isFirstPlay=!0,this.lastPlayTime=millis(),this.playSample("syn1",this.chordProgression[this.currentChordIndex]),this.currentChordIndex=(this.currentChordIndex+1)%this.chordProgression.length}stopAutoPlay(){this.isAutoPlaying=!1}midiNoteToRate(t){return midiToFreq(t)/this.baseFrequency}changeScale(t,e=0){this.scales[t]&&(this.currentScale=this.scales[t],this.rootNote=e)}snapToScale(t){let e=Math.floor(t/12),a=t%12;return 12*e+this.currentScale.map((t=>(t+this.rootNote)%12)).reduce(((t,e)=>Math.abs(e-a)<Math.abs(t-a)?e:t))}changeNoteRepeatPattern(t){this.noteRepeatPitchPatterns[t]&&(this.currentPatternName=t,this.noteRepeatPitchShifts=this.noteRepeatPitchPatterns[t])}setMasterGain(t){if(this.masterGain){const e=Math.max(this.masterGainParams.min,Math.min(t,this.masterGainParams.max));this.masterGain.gain.setTargetAtTime(e,inAudioContext.currentTime,.1)}}}